#program check(t).

proc(A,O,C,T) :- ordered(O,A), target(O,P), position(P,C), shelved(S,A), not position(S,C,0), position(S,C,t), T = t.
proc(A,O,C,T) :- ordered(O,A), target(O,P), position(P,C), shelved(S,A), position(S,C,0), carries(_,S,t), T = t.

:-     assign(S,P), isShelf(S), isStation(P), not proc(A,O,C,_), ordered(O,A), target(O,P), position(P,C), position(S,C,_), shelved(S,A).


% :- not assign(S,P), isShelf(S), isStation(P),	  process(A,O,C,t), ordered(O,A), target(O,P), position(P,C), position(S,C,t).
%:-     assign(S,P), isShelf(S), isStation(P), not process(A,O,C,t), ordered(O,A), target(O,P), position(P,C), position(S,C,t), query(t).

% es darf nicht sein, dass etwas zugewiesen ist und zu keinem Zeitpunkt ein ensprechendes process gemacht wird
%:-     assign(S,P), isShelf(S), isStation(P), not process(A,O,C,t), ordered(O,A), target(O,P), position(P,C), position(S,C,t), shelved(S,A), query(t).
%:-     assign(S,P), ordered(O,A), target(O,P), shelved(S,A), position(P,C), position(S,C,t), #count{ t : process(A,O,C,t) } < 1, query(t).
%:-     assign(S,P), ordered(O,A), target(O,P), shelved(S,A), position(P,C), position(S,C,t), processed(O,C,t).
%:- assign(S,P), isShelf(S), processed(O,C,t), #count{ t : process(S,P,t) } < 1.%target(O,P).


process(S,P,t) :- process(A,O,C,t), ordered(O,A), target(O,P), position(P,C), position(S,C,t), shelved(S,A).				

correct(S,P,t) 	  :-     assign(S,P), isShelf(S), isStation(P), process(A,O,C,t), ordered(O,A), target(O,P), position(P,C), position(S,C,t).
wrong(S,P,t)      :-     assign(S,P), isShelf(S), isStation(P), not process(A,O,C,t), ordered(O,A), target(O,P), position(P,C), position(S,C,t).
additional(S,P,t) :- not assign(S,P), isShelf(S), isStation(P), process(A,O,C,t), ordered(O,A), target(O,P), position(P,C), position(S,C,t).


#show assign/2.
#show correct/3.
#show additional/3.
#show wrong/3.
%#show process/3.
#show process/4.
#show proc/4.